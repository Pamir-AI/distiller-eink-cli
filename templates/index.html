<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E-ink Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f5;
            color: #333;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 280px;
            background: white;
            border-right: 1px solid #ddd;
            overflow-y: auto;
            padding: 20px;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .section {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }

        .section:last-child {
            border-bottom: none;
        }

        .section h3 {
            margin-bottom: 12px;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            color: #666;
            letter-spacing: 0.5px;
        }

        .canvas-info {
            text-align: center;
            color: #666;
            font-size: 18px;
            font-weight: 500;
        }

        .tool-group {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .tool-btn {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            font-size: 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .tool-btn.active {
            background: #000;
            color: white;
            border-color: #000;
        }

        .tool-btn:hover:not(.active) {
            background: #f8f8f8;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-group label {
            display: block;
            margin-bottom: 4px;
            font-size: 12px;
            font-weight: 500;
            color: #555;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }

        .form-group input[type="range"] {
            margin: 8px 0;
        }

        .form-group input[type="checkbox"] {
            width: auto;
            margin-right: 6px;
        }

        .radio-group {
            display: flex;
            gap: 12px;
        }

        .radio-group label {
            display: flex;
            align-items: center;
            font-size: 12px;
            margin-bottom: 0;
        }

        .radio-group input[type="radio"] {
            width: auto;
            margin-right: 4px;
        }

        .btn {
            padding: 8px 16px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            font-size: 12px;
            border-radius: 4px;
            transition: all 0.2s;
            width: 100%;
            margin-bottom: 8px;
        }

        .btn:hover {
            background: #f8f8f8;
        }

        .btn.primary {
            background: #000;
            color: white;
            border-color: #000;
        }

        .btn.primary:hover {
            background: #333;
        }

        .btn.danger {
            background: #dc3545;
            color: white;
            border-color: #dc3545;
        }

        .btn.danger:hover {
            background: #c82333;
        }

        .layers-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 12px;
        }

        .layer-item {
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .layer-item:last-child {
            border-bottom: none;
        }

        .layer-item:hover {
            background: #f8f8f8;
        }

        .layer-item.selected {
            background: #e3f2fd;
        }

        .layer-item.hidden {
            opacity: 0.5;
        }

        .layer-visibility {
            display: inline-block;
            width: 12px;
            font-size: 14px;
            font-weight: bold;
        }

        .layer-visibility.visible {
            color: #28a745;
        }

        .layer-visibility.hidden {
            color: #6c757d;
        }

        .layer-item.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
        }

        .layer-item.drop-target {
            border-top: 2px solid #007AFF;
        }

        .drag-handle {
            cursor: grab;
            color: #999;
            font-size: 14px;
            line-height: 1;
            user-select: none;
            margin-right: 8px;
        }

        .drag-handle:hover {
            color: #333;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .layer-content {
            flex: 1;
        }

        #toolProperties h4 {
            margin: 0 0 12px 0;
            padding: 8px;
            background: #f0f0f0;
            border-radius: 4px;
            font-size: 14px;
            color: #333;
        }

        .layer-controls {
            display: flex;
            gap: 4px;
        }

        .layer-controls button {
            padding: 2px 6px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            font-size: 10px;
            border-radius: 2px;
        }

        .preview-container {
            flex: 1;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .preview-canvas {
            width: 500px;
            height: 256px;
            max-width: 100%;
            border: 2px solid #000;
            cursor: crosshair;
            image-rendering: pixelated;
            position: relative;
            transition: filter 0.2s ease;
            object-fit: contain;
        }

        .preview-canvas.hovering-element {
            cursor: grab;
            filter: brightness(1.05);
        }

        .preview-canvas.dragging-element {
            cursor: grabbing;
            filter: brightness(0.95);
        }

        .element-highlight {
            position: absolute;
            border: 2px solid #007AFF;
            background: rgba(0, 122, 255, 0.1);
            pointer-events: none;
            border-radius: 3px;
            box-shadow: 0 0 8px rgba(0, 122, 255, 0.3);
            transition: all 0.15s ease;
        }

        .placeholder-preview {
            border: 2px dashed #666;
            background: rgba(200, 200, 200, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #666;
            position: absolute;
            pointer-events: none;
        }

        .file-input {
            margin-bottom: 12px;
        }

        .file-input input[type="file"] {
            width: 100%;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }

        .coords-display {
            font-size: 10px;
            color: #666;
            margin-top: 8px;
        }

        .status {
            padding: 8px 12px;
            border-radius: 4px;
            margin-bottom: 12px;
            font-size: 12px;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
                max-height: 50vh;
            }
            
            .main-content {
                flex: 1;
                min-height: 50vh;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="section">
                <h3>Canvas</h3>
                <div class="canvas-info" id="canvasInfo">250 √ó 128 (2x preview)</div>
            </div>

            <div class="section">
                <h3>Tools</h3>
                <div class="tool-group">
                    <button class="tool-btn active" data-tool="ip-placeholder">IP Address</button>
                    <button class="tool-btn" data-tool="qr-placeholder">QR Code</button>
                    <button class="tool-btn" data-tool="background-image">Background Image</button>
                </div>

                <div id="toolProperties">
                    <!-- Tool-specific properties will be loaded here -->
                </div>
            </div>

            <div class="section">
                <h3>Layers</h3>
                <div class="layers-list" id="layersList">
                    <!-- Layers will be loaded here -->
                </div>
                <div class="layer-controls">
                    <button class="btn" onclick="removeSelectedLayer()">Remove</button>
                    <button class="btn" onclick="toggleSelectedLayer()">Toggle</button>
                </div>
            </div>

            <div class="section" id="positionSection" style="display: none;">
                <h3>Position</h3>
                <div class="form-group">
                    <label>X Position:</label>
                    <input type="number" id="layerX" min="0" max="249" onchange="updateLayerPosition()">
                </div>
                <div class="form-group">
                    <label>Y Position:</label>
                    <input type="number" id="layerY" min="0" max="127" onchange="updateLayerPosition()">
                </div>
                <div class="form-group">
                    <button class="btn" onclick="centerSelectedLayer()">Center</button>
                </div>
            </div>

            <div class="section">
                <h3>Templates</h3>
                <button class="btn" onclick="saveTemplate()">üíæ Save Template</button>
                <button class="btn" onclick="loadTemplate()">üìÅ Load Template</button>
                <button class="btn" onclick="loadTemplateList()">üîÑ Refresh List</button>
                <input type="file" id="templateFileInput" accept=".json" style="display: none;" onchange="handleTemplateLoad()">
                
                <div id="templateList" style="margin-top: 10px;">
                    <small>Loading templates...</small>
                </div>
            </div>

            <div class="section">
                <h3>Actions</h3>
                <button class="btn danger" onclick="clearAll()">Clear All</button>
                {% if hardware_available %}
                <button class="btn primary" onclick="displayOnHardware()">Display</button>
                <button class="btn" onclick="clearHardware()">Clear Display</button>
                {% endif %}
                <button class="btn" onclick="downloadPNG()">Save PNG</button>
            </div>
        </div>

        <div class="main-content">
            <div id="statusMessage"></div>
            <div class="preview-container">
                <div style="position: relative; display: inline-block;">
                    <img id="previewCanvas" class="preview-canvas" src="" alt="E-ink Preview">
                    <div id="elementHighlight" class="element-highlight" style="display: none;"></div>
                </div>
                <div class="coords-display" id="coordsDisplay">Hover to highlight, click to select</div>
            </div>
        </div>
    </div>

    <!-- Hidden file input for template loading -->
    <input type="file" id="templateFileInput" accept=".json" style="display: none;">

    <script>
        let currentTool = 'ip-placeholder';
        let selectedLayer = null;
        let canvasScale = 1;
        let canvasOffset = { x: 0, y: 0 };
        let isDragging = false;
        let dragStartPos = { x: 0, y: 0 };
        let dragLayerIndex = null;
        let hoveredLayerIndex = null;
        let lastMousePos = { x: 0, y: 0 };
        let dragUpdateTimeout = null;
        let pendingLayerUpdate = null;
        let clientSideLayers = [];

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            updatePreview();
            updateLayers();
            setupToolProperties();
            setupEventListeners();
            loadTemplateList();  // Load available templates
        });

        function setupEventListeners() {
            // Tool selection
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentTool = this.dataset.tool;
                    setupToolProperties();
                });
            });

            // Canvas mouse events for hover, click and drag
            const canvas = document.getElementById('previewCanvas');
            const highlight = document.getElementById('elementHighlight');
            
            canvas.addEventListener('mousedown', async function(e) {
                const rect = this.getBoundingClientRect();
                const x = Math.round((e.clientX - rect.left) * (250 / rect.width));
                const y = Math.round((e.clientY - rect.top) * (128 / rect.height));
                
                // Check if clicking on an existing layer
                if (hoveredLayerIndex !== null) {
                    // Select the layer for editing
                    selectLayerByIndex(hoveredLayerIndex);
                    
                    // Start drag operation
                    isDragging = true;
                    dragLayerIndex = hoveredLayerIndex;
                    dragStartPos = { x: x, y: y };
                    canvas.classList.add('dragging-element');
                    canvas.classList.remove('hovering-element');
                    e.preventDefault();
                    console.log(`Starting drag for layer ${hoveredLayerIndex} at (${x}, ${y})`); // Debug
                    return;
                }
            });
            
            canvas.addEventListener('mousemove', async function(e) {
                const rect = this.getBoundingClientRect();
                const x = Math.round((e.clientX - rect.left) * (250 / rect.width));
                const y = Math.round((e.clientY - rect.top) * (128 / rect.height));
                
                lastMousePos = { x, y };
                
                if (isDragging && dragLayerIndex !== null) {
                    // Handle dragging with client-side preview
                    const deltaX = x - dragStartPos.x;
                    const deltaY = y - dragStartPos.y;
                    
                    if (Math.abs(deltaX) > 0 || Math.abs(deltaY) > 0) {
                        // Update client-side immediately for smooth preview
                        updateLayerPositionClientSide(dragLayerIndex, deltaX, deltaY);
                        
                        // Debounce server update
                        debouncedServerUpdate(dragLayerIndex, deltaX, deltaY);
                        
                        dragStartPos = { x: x, y: y };
                    }
                    
                    document.getElementById('coordsDisplay').textContent = `${x}, ${y} (dragging)`;
                } else {
                    // Handle hover detection for highlighting
                    const layerIndex = await findLayerAtPosition(x, y);
                    
                    if (layerIndex !== hoveredLayerIndex) {
                        hoveredLayerIndex = layerIndex;
                        updateElementHighlight(layerIndex, rect);
                    }
                    
                    // Update cursor and coordinates display
                    if (layerIndex !== null) {
                        canvas.classList.add('hovering-element');
                        document.getElementById('coordsDisplay').textContent = `${x}, ${y} (click to select/drag)`;
                    } else {
                        canvas.classList.remove('hovering-element');
                        document.getElementById('coordsDisplay').textContent = `${x}, ${y}`;
                    }
                }
            });
            
            canvas.addEventListener('mouseup', function(e) {
                if (isDragging) {
                    console.log('Ending drag operation'); // Debug
                    isDragging = false;
                    dragLayerIndex = null;
                    canvas.classList.remove('dragging-element');
                    
                    // Ensure final server sync
                    if (dragUpdateTimeout) {
                        clearTimeout(dragUpdateTimeout);
                    }
                    if (pendingLayerUpdate) {
                        const update = pendingLayerUpdate;
                        pendingLayerUpdate = null;
                        updateLayerPositionByDelta(update.layerIndex, update.totalDeltaX, update.totalDeltaY);
                    }
                    
                    // Re-trigger hover detection
                    setTimeout(() => {
                        canvas.dispatchEvent(new MouseEvent('mousemove', {
                            clientX: e.clientX,
                            clientY: e.clientY
                        }));
                    }, 10);
                }
            });
            
            canvas.addEventListener('mouseleave', function() {
                // Clean up hover state
                hoveredLayerIndex = null;
                highlight.style.display = 'none';
                canvas.classList.remove('hovering-element');
                
                if (isDragging) {
                    isDragging = false;
                    dragLayerIndex = null;
                    canvas.classList.remove('dragging-element');
                }
                
                document.getElementById('coordsDisplay').textContent = 'Hover to highlight, click to select';
            });


            // Template file input
            document.getElementById('templateFileInput').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const template = JSON.parse(e.target.result);
                            fetch('/api/load-template', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ template })
                            })
                            .then(response => response.json())
                            .then(data => {
                                if (data.success) {
                                    showStatus('Template loaded successfully', 'success');
                                    updatePreview();
                                    updateLayers();
                                } else {
                                    showStatus('Error loading template: ' + data.error, 'error');
                                }
                            });
                        } catch (err) {
                            showStatus('Invalid template file', 'error');
                        }
                    };
                    reader.readAsText(file);
                }
            });
        }

        function setupToolProperties() {
            const props = document.getElementById('toolProperties');
            
            if (currentTool === 'ip-placeholder') {
                props.innerHTML = `
                    <div class="form-group">
                        <label>Font Size: <span id="ipFontSizeValue">1</span></label>
                        <input type="range" id="ipFontSize" min="1" max="4" value="1">
                    </div>
                    <div class="form-group">
                        <label>Color:</label>
                        <div class="radio-group">
                            <label><input type="radio" name="ipColor" value="0" checked> Black</label>
                            <label><input type="radio" name="ipColor" value="255"> White</label>
                        </div>
                    </div>
                    <div class="form-group">
                        <label><input type="checkbox" id="ipBackground" checked> Background</label>
                    </div>
                    <div class="form-group">
                        <label>Rotation:</label>
                        <select id="ipRotation">
                            <option value="0">0¬∞</option>
                            <option value="90">90¬∞</option>
                            <option value="180">180¬∞</option>
                            <option value="270">270¬∞</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label><input type="checkbox" id="ipFlipH"> Flip Horizontal</label>
                    </div>
                    <button class="btn primary" onclick="addIPPlaceholder()">Add IP Placeholder</button>
                `;
                
                document.getElementById('ipFontSize').addEventListener('input', function() {
                    document.getElementById('ipFontSizeValue').textContent = this.value;
                });
            }
            else if (currentTool === 'qr-placeholder') {
                props.innerHTML = `
                    <div class="form-group">
                        <label>Width:</label>
                        <input type="number" id="qrWidth" value="70" min="20" max="150">
                    </div>
                    <div class="form-group">
                        <label>Height:</label>
                        <input type="number" id="qrHeight" value="70" min="20" max="150">
                    </div>
                    <button class="btn primary" onclick="addQRPlaceholder()">Add QR Placeholder</button>
                `;
            }
            else if (currentTool === 'background-image') {
                props.innerHTML = `
                    <div class="form-group">
                        <label>Image File:</label>
                        <input type="file" id="imageFile" accept="image/*" onchange="previewImageFile()">
                    </div>
                    <div class="form-group">
                        <label>Resize Mode:</label>
                        <select id="imageResizeMode">
                            <option value="fit">Fit (maintain aspect ratio)</option>
                            <option value="stretch">Stretch to fill</option>
                            <option value="crop">Crop to fill</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Dithering:</label>
                        <select id="imageDithering">
                            <option value="floyd-steinberg">Floyd-Steinberg</option>
                            <option value="threshold">Threshold</option>
                            <option value="none">None</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Brightness: <span id="imageBrightnessValue">1.0</span></label>
                        <input type="range" id="imageBrightness" min="0.1" max="2.0" step="0.1" value="1.0">
                    </div>
                    <div class="form-group">
                        <label>Contrast: <span id="imageContrastValue">0.0</span></label>
                        <input type="range" id="imageContrast" min="-1.0" max="1.0" step="0.1" value="0.0">
                    </div>
                    <div class="form-group">
                        <label>Rotation:</label>
                        <select id="imageRotation">
                            <option value="0">0¬∞</option>
                            <option value="90">90¬∞</option>
                            <option value="180">180¬∞</option>
                            <option value="270">270¬∞</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label><input type="checkbox" id="imageFlipH"> Flip Horizontal</label>
                    </div>
                    <div class="form-group">
                        <label><input type="checkbox" id="imageFlipV"> Flip Vertical</label>
                    </div>
                    <div class="form-group">
                        <label>Custom Width:</label>
                        <input type="number" id="imageWidth" min="1" max="250" placeholder="Auto">
                    </div>
                    <div class="form-group">
                        <label>Custom Height:</label>
                        <input type="number" id="imageHeight" min="1" max="128" placeholder="Auto">
                    </div>
                    <button class="btn primary" onclick="addBackgroundImage()" disabled id="addImageBtn">Add Background Image</button>
                `;
                
                // Add event listeners for sliders
                document.getElementById('imageBrightness').addEventListener('input', function() {
                    document.getElementById('imageBrightnessValue').textContent = this.value;
                });
                
                document.getElementById('imageContrast').addEventListener('input', function() {
                    document.getElementById('imageContrastValue').textContent = this.value;
                });
            }
        }



        function addIPPlaceholderAt(x, y) {
            const fontSize = document.getElementById('ipFontSize').value;
            const color = document.querySelector('input[name="ipColor"]:checked').value;
            const background = document.getElementById('ipBackground').checked;
            const rotation = document.getElementById('ipRotation').value;
            const flipH = document.getElementById('ipFlipH').checked;

            fetch('/api/add-ip-placeholder', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    x, y, 
                    font_size: fontSize, 
                    color, 
                    background,
                    rotation,
                    flip_h: flipH
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    updatePreview();
                    updateLayers();
                    syncLayersFromServer(); // Sync client cache
                } else {
                    showStatus('Error adding IP placeholder: ' + data.error, 'error');
                }
            });
        }

        function addIPPlaceholder() {
            addIPPlaceholderAt(125, 64); // Center of canvas
        }

        function addQRPlaceholderAt(x, y) {
            const width = document.getElementById('qrWidth').value;
            const height = document.getElementById('qrHeight').value;

            fetch('/api/add-qr-placeholder', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    x, y, 
                    width, 
                    height
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    updatePreview();
                    updateLayers();
                    syncLayersFromServer(); // Sync client cache
                } else {
                    showStatus('Error adding QR placeholder: ' + data.error, 'error');
                }
            });
        }

        function addQRPlaceholder() {
            addQRPlaceholderAt(125, 64); // Center of canvas
        }

        function previewImageFile() {
            const fileInput = document.getElementById('imageFile');
            const addBtn = document.getElementById('addImageBtn');
            
            if (fileInput.files && fileInput.files[0]) {
                addBtn.disabled = false;
            } else {
                addBtn.disabled = true;
            }
        }

        function addBackgroundImageAt(x, y) {
            const fileInput = document.getElementById('imageFile');
            
            if (!fileInput.files || !fileInput.files[0]) {
                showStatus('Please select an image file first', 'error');
                return;
            }

            const formData = new FormData();
            formData.append('image', fileInput.files[0]);
            formData.append('x', x);
            formData.append('y', y);
            formData.append('resize_mode', document.getElementById('imageResizeMode').value);
            formData.append('dither', document.getElementById('imageDithering').value);
            formData.append('brightness', document.getElementById('imageBrightness').value);
            formData.append('contrast', document.getElementById('imageContrast').value);
            formData.append('rotate', document.getElementById('imageRotation').value);
            formData.append('flip_h', document.getElementById('imageFlipH').checked);
            formData.append('flip_v', document.getElementById('imageFlipV').checked);
            
            const customWidth = document.getElementById('imageWidth').value;
            const customHeight = document.getElementById('imageHeight').value;
            if (customWidth) formData.append('width', customWidth);
            if (customHeight) formData.append('height', customHeight);

            fetch('/api/add-image', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    updatePreview();
                    updateLayers();
                    syncLayersFromServer();
                    showStatus('Background image added successfully', 'success');
                    
                    // Reset file input
                    document.getElementById('imageFile').value = '';
                    document.getElementById('addImageBtn').disabled = true;
                } else {
                    showStatus('Error adding image: ' + data.error, 'error');
                }
            })
            .catch(error => {
                showStatus('Error uploading image: ' + error.message, 'error');
            });
        }

        function addBackgroundImage() {
            addBackgroundImageAt(125, 64); // Center of canvas
        }

        // Drag and Drop variables
        let draggedElement = null;
        let draggedLayerId = null;

        function handleDragStart(e) {
            draggedElement = e.target;
            draggedLayerId = e.target.dataset.layerId;
            e.target.classList.add('dragging');
            
            // Set drag effect
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.outerHTML);
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            // Find the layer-item element (might be a child element)
            let targetLayerItem = e.target;
            while (targetLayerItem && !targetLayerItem.classList.contains('layer-item')) {
                targetLayerItem = targetLayerItem.parentElement;
            }
            
            // Add drop target indicator
            if (targetLayerItem && targetLayerItem !== draggedElement) {
                // Remove existing drop targets
                document.querySelectorAll('.drop-target').forEach(item => {
                    item.classList.remove('drop-target');
                });
                
                targetLayerItem.classList.add('drop-target');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            
            // Find the layer-item element (might be a child element)
            let targetLayerItem = e.target;
            while (targetLayerItem && !targetLayerItem.classList.contains('layer-item')) {
                targetLayerItem = targetLayerItem.parentElement;
            }
            
            if (targetLayerItem && targetLayerItem !== draggedElement) {
                const targetIndex = parseInt(targetLayerItem.dataset.layerIndex);
                
                // Move layer on server
                fetch('/api/move-layer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        layer_id: draggedLayerId,
                        new_index: targetIndex
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Refresh layer list and preview
                        updateLayers();
                        updatePreview();
                        syncLayersFromServer();
                    } else {
                        console.error('Error moving layer:', data.error);
                    }
                })
                .catch(error => {
                    console.error('Error moving layer:', error);
                });
            }
            
            // Clean up
            handleDragEnd();
        }

        function handleDragEnd(e) {
            // Remove all drag-related classes
            document.querySelectorAll('.dragging').forEach(item => {
                item.classList.remove('dragging');
            });
            document.querySelectorAll('.drop-target').forEach(item => {
                item.classList.remove('drop-target');
            });
            
            draggedElement = null;
            draggedLayerId = null;
        }


        function updatePreview() {
            fetch('/api/preview')
            .then(response => response.json())
            .then(data => {
                document.getElementById('previewCanvas').src = data.image;
                document.getElementById('canvasInfo').textContent = `${data.width} √ó ${data.height}`;
            });
        }

        function updateLayers() {
            fetch('/api/layers')
            .then(response => response.json())
            .then(layers => {
                const list = document.getElementById('layersList');
                list.innerHTML = '';
                
                layers.forEach((layer, index) => {
                    const item = document.createElement('div');
                    item.className = `layer-item ${!layer.visible ? 'hidden' : ''}`;
                    item.draggable = true;
                    item.dataset.layerIndex = index;
                    item.dataset.layerId = layer.id;
                    item.innerHTML = `
                        <span class="drag-handle" draggable="false">‚ãÆ‚ãÆ</span>
                        <span class="layer-content"><span class="layer-visibility ${layer.visible ? 'visible' : 'hidden'}">${layer.visible ? '‚óè' : '‚óã'}</span> ${layer.id} (${layer.type})</span>
                    `;
                    item.addEventListener('click', () => selectLayer(index, item));
                    
                    // Add drag event listeners
                    item.addEventListener('dragstart', handleDragStart);
                    item.addEventListener('dragover', handleDragOver);
                    item.addEventListener('drop', handleDrop);
                    item.addEventListener('dragend', handleDragEnd);
                    
                    list.appendChild(item);
                });
            });
        }

        function selectLayer(index, element) {
            document.querySelectorAll('.layer-item').forEach(item => item.classList.remove('selected'));
            element.classList.add('selected');
            selectedLayer = index;
            showLayerProperties();
        }

        function selectLayerByIndex(index) {
            const layerItems = document.querySelectorAll('.layer-item');
            if (index < layerItems.length) {
                selectLayer(index, layerItems[index]);
            }
        }

        function showLayerProperties() {
            if (selectedLayer === null) {
                document.getElementById('positionSection').style.display = 'none';
                return;
            }
            
            fetch('/api/layers')
            .then(response => response.json())
            .then(layers => {
                if (selectedLayer < layers.length) {
                    const layer = layers[selectedLayer];
                    
                    // Show position controls
                    document.getElementById('layerX').value = layer.x;
                    document.getElementById('layerY').value = layer.y;
                    document.getElementById('positionSection').style.display = 'block';
                    
                    // Update tool properties to show selected layer's properties
                    showLayerSpecificProperties(layer);
                }
            });
        }

        function showLayerSpecificProperties(layer) {
            const props = document.getElementById('toolProperties');
            
            if (layer.type === 'text') {
                props.innerHTML = `
                    <h4>Editing: ${layer.id} (Text)</h4>
                    <div class="form-group">
                        <label>Text:</label>
                        <input type="text" id="editText" value="${layer.text}" onchange="updateLayerProperty('text', this.value)">
                    </div>
                    <div class="form-group">
                        <label>Font Size: <span id="editFontSizeValue">${layer.font_size}</span></label>
                        <input type="range" id="editFontSize" min="1" max="4" value="${layer.font_size}" onchange="updateLayerProperty('font_size', this.value); document.getElementById('editFontSizeValue').textContent = this.value;">
                    </div>
                    <div class="form-group">
                        <label>Color:</label>
                        <div class="radio-group">
                            <label><input type="radio" name="editColor" value="0" ${layer.color === 0 ? 'checked' : ''} onchange="updateLayerProperty('color', 0)"> Black</label>
                            <label><input type="radio" name="editColor" value="255" ${layer.color === 255 ? 'checked' : ''} onchange="updateLayerProperty('color', 255)"> White</label>
                        </div>
                    </div>
                    <div class="form-group">
                        <label><input type="checkbox" id="editBackground" ${layer.background ? 'checked' : ''} onchange="updateLayerProperty('background', this.checked)"> Background</label>
                    </div>
                `;
            } else if (layer.type === 'rectangle') {
                props.innerHTML = `
                    <h4>Editing: ${layer.id} (Rectangle)</h4>
                    <div class="form-group">
                        <label>Width:</label>
                        <input type="number" id="editWidth" value="${layer.width}" min="1" max="250" onchange="updateLayerProperty('width', parseInt(this.value))">
                    </div>
                    <div class="form-group">
                        <label>Height:</label>
                        <input type="number" id="editHeight" value="${layer.height}" min="1" max="128" onchange="updateLayerProperty('height', parseInt(this.value))">
                    </div>
                    <div class="form-group">
                        <label><input type="checkbox" id="editFilled" ${layer.filled ? 'checked' : ''} onchange="updateLayerProperty('filled', this.checked)"> Filled</label>
                    </div>
                `;
            } else if (layer.placeholder_type === 'qr') {
                props.innerHTML = `
                    <h4>Editing: ${layer.id} (QR Code)</h4>
                    <div class="form-group">
                        <label>Width:</label>
                        <input type="number" id="editWidth" value="${layer.width || 70}" min="20" max="150" onchange="updateLayerProperty('width', parseInt(this.value))">
                    </div>
                    <div class="form-group">
                        <label>Height:</label>
                        <input type="number" id="editHeight" value="${layer.height || 70}" min="20" max="150" onchange="updateLayerProperty('height', parseInt(this.value))">
                    </div>
                `;
            } else if (layer.type === 'image') {
                props.innerHTML = `
                    <h4>Editing: ${layer.id} (Image)</h4>
                    <div class="form-group">
                        <label>Brightness: <span id="editBrightnessValue">${layer.brightness}</span></label>
                        <input type="range" id="editBrightness" min="0.1" max="2.0" step="0.1" value="${layer.brightness}" onchange="updateLayerProperty('brightness', parseFloat(this.value)); document.getElementById('editBrightnessValue').textContent = this.value;">
                    </div>
                    <div class="form-group">
                        <label>Contrast: <span id="editContrastValue">${layer.contrast}</span></label>
                        <input type="range" id="editContrast" min="-1.0" max="1.0" step="0.1" value="${layer.contrast}" onchange="updateLayerProperty('contrast', parseFloat(this.value)); document.getElementById('editContrastValue').textContent = this.value;">
                    </div>
                    <div class="form-group">
                        <label>Rotation:</label>
                        <select id="editRotation" onchange="updateLayerProperty('rotate', parseInt(this.value))">
                            <option value="0" ${layer.rotate === 0 ? 'selected' : ''}>0¬∞</option>
                            <option value="90" ${layer.rotate === 90 ? 'selected' : ''}>90¬∞</option>
                            <option value="180" ${layer.rotate === 180 ? 'selected' : ''}>180¬∞</option>
                            <option value="270" ${layer.rotate === 270 ? 'selected' : ''}>270¬∞</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label><input type="checkbox" id="editFlipH" ${layer.flip_h ? 'checked' : ''} onchange="updateLayerProperty('flip_h', this.checked)"> Flip Horizontal</label>
                    </div>
                    <div class="form-group">
                        <label><input type="checkbox" id="editFlipV" ${layer.flip_v ? 'checked' : ''} onchange="updateLayerProperty('flip_v', this.checked)"> Flip Vertical</label>
                    </div>
                `;
            }
        }

        function updateLayerProperty(property, value) {
            if (selectedLayer === null) return;
            
            fetch('/api/layers')
            .then(response => response.json())
            .then(layers => {
                if (selectedLayer < layers.length) {
                    const layerId = layers[selectedLayer].id;
                    
                    // Update the layer property on the server
                    fetch(`/api/update-layer/${layerId}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ [property]: value })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Update preview immediately
                            updatePreview();
                        } else {
                            console.error('Error updating layer property:', data.error);
                        }
                    })
                    .catch(error => {
                        console.error('Error updating layer property:', error);
                    });
                }
            });
        }

        function updateLayerPosition() {
            if (selectedLayer === null) return;
            
            const x = parseInt(document.getElementById('layerX').value);
            const y = parseInt(document.getElementById('layerY').value);
            
            fetch('/api/layers')
            .then(response => response.json())
            .then(layers => {
                if (selectedLayer < layers.length) {
                    const layerId = layers[selectedLayer].id;
                    fetch('/api/update-layer-position', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ layer_id: layerId, x: x, y: y })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            updatePreview();
                        }
                    });
                }
            });
        }

        function centerSelectedLayer() {
            if (selectedLayer === null) return;
            
            document.getElementById('layerX').value = 125;
            document.getElementById('layerY').value = 64;
            updateLayerPosition();
        }

        async function findLayerAtPosition(x, y) {
            // Simple approximation - in a real app you'd need better hit testing
            // For now, just return the top visible layer that might be at this position
            try {
                // Use client-side cache if available and during drag, otherwise fetch from server
                let layers;
                if (clientSideLayers.length > 0) {
                    layers = clientSideLayers;
                } else {
                    const response = await fetch('/api/layers');
                    layers = await response.json();
                    clientSideLayers = [...layers]; // Cache for future use
                }
                
                console.log(`Checking click at (${x}, ${y}) against ${layers.length} layers`); // Debug
                
                // Check layers from top to bottom (reverse order)
                for (let i = layers.length - 1; i >= 0; i--) {
                    const layer = layers[i];
                    if (!layer.visible) continue;
                    
                    // Simple bounding box check - handle placeholder types
                    let layerWidth, layerHeight;
                    
                    if (layer.placeholder_type === 'ip') {
                        // IP text placeholder
                        const textLength = layer.text ? layer.text.length : 12; // "$IP_ADDRESS".length
                        layerWidth = textLength * 6 * (layer.font_size || 1);
                        layerHeight = 8 * (layer.font_size || 1);
                    } else if (layer.placeholder_type === 'qr') {
                        // QR code placeholder
                        layerWidth = layer.width || 70;
                        layerHeight = layer.height || 70;
                    } else if (layer.type === 'text') {
                        layerWidth = (layer.text ? layer.text.length : 5) * 6 * (layer.font_size || 1);
                        layerHeight = 8 * (layer.font_size || 1);
                    } else if (layer.type === 'rectangle') {
                        layerWidth = layer.width || 50;
                        layerHeight = layer.height || 50;
                    } else if (layer.type === 'image') {
                        // For image layers, calculate actual rendered dimensions
                        if (layer.width && layer.height) {
                            // Custom dimensions specified
                            layerWidth = layer.width;
                            layerHeight = layer.height;
                        } else {
                            // Use remaining canvas space (matches composer logic)
                            layerWidth = 250 - layer.x;
                            layerHeight = 128 - layer.y;
                        }
                    } else {
                        layerWidth = layer.width || 50;
                        layerHeight = layer.height || 50;
                    }
                    
                    const inBounds = x >= layer.x && x <= layer.x + layerWidth &&
                                   y >= layer.y && y <= layer.y + layerHeight;
                    
                    console.log(`Layer ${i} (${layer.id}): bounds=(${layer.x},${layer.y},${layerWidth},${layerHeight}) inBounds=${inBounds}`); // Debug
                    
                    if (inBounds) {
                        console.log(`Found layer ${i} at click position`); // Debug
                        return i;
                    }
                }
                console.log('No layer found at click position'); // Debug
                return null;
            } catch (error) {
                console.log('Error finding layer:', error); // Debug
                return null;
            }
        }

        async function updateElementHighlight(layerIndex, canvasRect) {
            const highlight = document.getElementById('elementHighlight');
            
            if (layerIndex === null) {
                highlight.style.display = 'none';
                return;
            }
            
            try {
                const response = await fetch('/api/layers');
                const layers = await response.json();
                
                if (layerIndex >= layers.length) {
                    highlight.style.display = 'none';
                    return;
                }
                
                const layer = layers[layerIndex];
                let layerWidth, layerHeight;
                
                // Calculate layer dimensions (same logic as findLayerAtPosition)
                if (layer.placeholder_type === 'ip') {
                    const textLength = layer.text ? layer.text.length : 12;
                    layerWidth = textLength * 6 * (layer.font_size || 1);
                    layerHeight = 8 * (layer.font_size || 1);
                } else if (layer.placeholder_type === 'qr') {
                    layerWidth = layer.width || 70;
                    layerHeight = layer.height || 70;
                } else if (layer.type === 'text') {
                    layerWidth = (layer.text ? layer.text.length : 5) * 6 * (layer.font_size || 1);
                    layerHeight = 8 * (layer.font_size || 1);
                } else if (layer.type === 'rectangle') {
                    layerWidth = layer.width || 50;
                    layerHeight = layer.height || 50;
                } else if (layer.type === 'image') {
                    // For image layers, calculate actual rendered dimensions
                    if (layer.width && layer.height) {
                        // Custom dimensions specified
                        layerWidth = layer.width;
                        layerHeight = layer.height;
                    } else {
                        // Use remaining canvas space (matches composer logic)
                        layerWidth = 250 - layer.x;
                        layerHeight = 128 - layer.y;
                    }
                } else {
                    layerWidth = layer.width || 50;
                    layerHeight = layer.height || 50;
                }
                
                // Convert layer coordinates to canvas pixel coordinates
                const scaleX = canvasRect.width / 250;
                const scaleY = canvasRect.height / 128;
                
                const highlightX = layer.x * scaleX;
                const highlightY = layer.y * scaleY;
                const highlightWidth = layerWidth * scaleX;
                const highlightHeight = layerHeight * scaleY;
                
                // Position the highlight overlay
                highlight.style.left = highlightX + 'px';
                highlight.style.top = highlightY + 'px';
                highlight.style.width = highlightWidth + 'px';
                highlight.style.height = highlightHeight + 'px';
                highlight.style.display = 'block';
                
                console.log(`Highlighting layer ${layerIndex} at (${highlightX}, ${highlightY}) size (${highlightWidth}, ${highlightHeight})`); // Debug
                
            } catch (error) {
                console.log('Error updating highlight:', error);
                highlight.style.display = 'none';
            }
        }

        function updateLayerPositionByDelta(layerIndex, deltaX, deltaY) {
            console.log(`Updating layer ${layerIndex} by delta (${deltaX}, ${deltaY})`); // Debug
            
            fetch('/api/layers')
            .then(response => response.json())
            .then(layers => {
                if (layerIndex < layers.length) {
                    const layer = layers[layerIndex];
                    const newX = Math.max(0, Math.min(249, layer.x + deltaX));
                    const newY = Math.max(0, Math.min(127, layer.y + deltaY));
                    
                    console.log(`Moving layer ${layer.id} from (${layer.x}, ${layer.y}) to (${newX}, ${newY})`); // Debug
                    
                    fetch('/api/update-layer-position', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ layer_id: layer.id, x: newX, y: newY })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            updatePreview();
                            // Update position controls if this is the selected layer
                            if (layerIndex === selectedLayer) {
                                document.getElementById('layerX').value = newX;
                                document.getElementById('layerY').value = newY;
                            }
                        } else {
                            console.log('Failed to update layer position:', data); // Debug
                        }
                    });
                }
            });
        }

        function updateLayerPositionClientSide(layerIndex, deltaX, deltaY) {
            // Update client-side layer cache for immediate visual feedback
            if (!clientSideLayers.length) {
                // Initialize cache if empty
                fetch('/api/layers')
                .then(response => response.json())
                .then(layers => {
                    clientSideLayers = [...layers];
                    if (layerIndex < clientSideLayers.length) {
                        clientSideLayers[layerIndex].x = Math.max(0, Math.min(249, clientSideLayers[layerIndex].x + deltaX));
                        clientSideLayers[layerIndex].y = Math.max(0, Math.min(127, clientSideLayers[layerIndex].y + deltaY));
                        updateHighlightPosition(layerIndex);
                    }
                });
            } else {
                if (layerIndex < clientSideLayers.length) {
                    clientSideLayers[layerIndex].x = Math.max(0, Math.min(249, clientSideLayers[layerIndex].x + deltaX));
                    clientSideLayers[layerIndex].y = Math.max(0, Math.min(127, clientSideLayers[layerIndex].y + deltaY));
                    updateHighlightPosition(layerIndex);
                    
                    // Update position controls if this is the selected layer
                    if (layerIndex === selectedLayer) {
                        document.getElementById('layerX').value = clientSideLayers[layerIndex].x;
                        document.getElementById('layerY').value = clientSideLayers[layerIndex].y;
                    }
                }
            }
        }

        function updateHighlightPosition(layerIndex) {
            // Update highlight position without server call
            const highlight = document.getElementById('elementHighlight');
            const canvas = document.getElementById('previewCanvas');
            const rect = canvas.getBoundingClientRect();
            
            if (layerIndex < clientSideLayers.length) {
                const layer = clientSideLayers[layerIndex];
                let layerWidth, layerHeight;
                
                // Calculate layer dimensions (same logic as findLayerAtPosition)
                if (layer.placeholder_type === 'ip') {
                    const textLength = layer.text ? layer.text.length : 12; // "$IP_ADDRESS".length
                    layerWidth = textLength * 6 * (layer.font_size || 1);
                    layerHeight = 8 * (layer.font_size || 1);
                } else if (layer.placeholder_type === 'qr') {
                    layerWidth = layer.width || 70;
                    layerHeight = layer.height || 70;
                } else if (layer.type === 'text') {
                    layerWidth = (layer.text ? layer.text.length : 5) * 6 * (layer.font_size || 1);
                    layerHeight = 8 * (layer.font_size || 1);
                } else if (layer.type === 'rectangle') {
                    layerWidth = layer.width || 50;
                    layerHeight = layer.height || 50;
                } else if (layer.type === 'image') {
                    // For image layers, calculate actual rendered dimensions
                    if (layer.width && layer.height) {
                        // Custom dimensions specified
                        layerWidth = layer.width;
                        layerHeight = layer.height;
                    } else {
                        // Use remaining canvas space (matches composer logic)
                        layerWidth = 250 - layer.x;
                        layerHeight = 128 - layer.y;
                    }
                } else {
                    // For unknown types
                    layerWidth = layer.width || 50;
                    layerHeight = layer.height || 50;
                }
                
                // Convert to canvas coordinates
                const scaleX = rect.width / 250;
                const scaleY = rect.height / 128;
                
                highlight.style.left = (layer.x * scaleX) + 'px';
                highlight.style.top = (layer.y * scaleY) + 'px';
                highlight.style.width = (layerWidth * scaleX) + 'px';
                highlight.style.height = (layerHeight * scaleY) + 'px';
            }
        }

        function debouncedServerUpdate(layerIndex, deltaX, deltaY) {
            // Clear previous timeout
            if (dragUpdateTimeout) {
                clearTimeout(dragUpdateTimeout);
            }
            
            // Store the pending update
            if (!pendingLayerUpdate) {
                pendingLayerUpdate = { layerIndex, totalDeltaX: 0, totalDeltaY: 0 };
            }
            pendingLayerUpdate.totalDeltaX += deltaX;
            pendingLayerUpdate.totalDeltaY += deltaY;
            
            // Set new timeout to send update to server
            dragUpdateTimeout = setTimeout(() => {
                if (pendingLayerUpdate) {
                    const update = pendingLayerUpdate;
                    pendingLayerUpdate = null;
                    
                    // Send accumulated delta to server
                    updateLayerPositionByDelta(update.layerIndex, update.totalDeltaX, update.totalDeltaY);
                }
            }, 50); // Update server every 50ms instead of every mouse move
        }

        function syncLayersFromServer() {
            // Resync client cache with server state
            fetch('/api/layers')
            .then(response => response.json())
            .then(layers => {
                clientSideLayers = [...layers];
            });
        }

        function removeSelectedLayer() {
            if (selectedLayer === null) return;
            
            fetch('/api/layers')
            .then(response => response.json())
            .then(layers => {
                if (selectedLayer < layers.length) {
                    const layerId = layers[selectedLayer].id;
                    fetch('/api/remove-layer', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ layer_id: layerId })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            updatePreview();
                            updateLayers();
                            selectedLayer = null;
                        }
                    });
                }
            });
        }

        function toggleSelectedLayer() {
            if (selectedLayer === null) return;
            
            fetch('/api/layers')
            .then(response => response.json())
            .then(layers => {
                if (selectedLayer < layers.length) {
                    const layerId = layers[selectedLayer].id;
                    fetch('/api/toggle-layer', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ layer_id: layerId })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            updatePreview();
                            updateLayers();
                        }
                    });
                }
            });
        }

        function clearAll() {
            if (confirm('Clear all layers?')) {
                fetch('/api/clear')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        updatePreview();
                        updateLayers();
                        selectedLayer = null;
                    }
                });
            }
        }

        function displayOnHardware() {
            fetch('/api/display', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({})
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showStatus('Displayed on e-ink hardware', 'success');
                } else {
                    showStatus('Error displaying: ' + data.error, 'error');
                }
            });
        }

        function clearHardware() {
            fetch('/api/hardware/clear', {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showStatus('Hardware display cleared', 'success');
                } else {
                    showStatus('Error clearing display: ' + data.error, 'error');
                }
            });
        }

        function downloadPNG() {
            window.open('/api/download-png', '_blank');
        }

        function saveTemplate() {
            const templateName = prompt('Enter template name:', 'my_template');
            if (!templateName) return;
            
            fetch('/api/export-template', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: templateName })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    showStatus('Error: ' + data.error, 'error');
                    return;
                }
                
                if (data.success) {
                    showStatus(`Template package "${templateName}" saved with ${data.files} files`, 'success');
                    loadTemplateList(); // Refresh template list
                } else {
                    showStatus('Template saved', 'success');
                }
            })
            .catch(error => {
                showStatus('Error saving template: ' + error.message, 'error');
            });
        }

        function loadTemplate() {
            document.getElementById('templateFileInput').click();
        }

        function handleTemplateLoad() {
            const fileInput = document.getElementById('templateFileInput');
            const file = fileInput.files[0];
            
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const templateData = JSON.parse(e.target.result);
                    
                    // Import template (old single-file format)
                    fetch('/api/import-template', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            template_data: templateData,
                            template_path: ''  // No path for single file
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            showStatus('Template loaded successfully!', 'success');
                            updateLayers();
                            updatePreview();
                        } else {
                            showStatus('Error loading template: ' + data.error, 'error');
                        }
                    })
                    .catch(error => {
                        showStatus('Error loading template: ' + error.message, 'error');
                    });
                } catch (error) {
                    showStatus('Invalid template file: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
            
            // Clear the input so the same file can be loaded again
            fileInput.value = '';
        }

        function loadTemplateList() {
            fetch('/api/list-templates')
            .then(response => response.json())
            .then(data => {
                const templateList = document.getElementById('templateList');
                
                if (data.error) {
                    templateList.innerHTML = `<small style="color: red;">Error: ${data.error}</small>`;
                    return;
                }
                
                if (data.templates.length === 0) {
                    templateList.innerHTML = '<small>No templates found. Create one first!</small>';
                    return;
                }
                
                let html = '<div style="max-height: 150px; overflow-y: auto;">';
                data.templates.forEach(template => {
                    html += `
                        <div style="padding: 5px; border: 1px solid #ddd; margin: 2px 0; border-radius: 3px; background: white;">
                            <strong>${template.display_name}</strong><br>
                            <small>${template.layers_count} layers | ${template.created}</small><br>
                            <button class="btn" style="margin-top: 5px; padding: 4px 8px;" 
                                    onclick="loadTemplatePackage('${template.path}')">
                                üìÇ Load
                            </button>
                        </div>
                    `;
                });
                html += '</div>';
                templateList.innerHTML = html;
            })
            .catch(error => {
                document.getElementById('templateList').innerHTML = `<small style="color: red;">Error loading templates: ${error.message}</small>`;
            });
        }

        function loadTemplatePackage(templatePath) {
            // Load template.json from the package
            fetch(`/${templatePath}/template.json`)
            .then(response => response.json())
            .then(templateData => {
                // Import template package
                fetch('/api/import-template', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        template_data: templateData,
                        template_path: templatePath
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        showStatus(`Template "${templateData.name || 'package'}" loaded successfully!`, 'success');
                        updateLayers();
                        updatePreview();
                    } else {
                        showStatus('Error loading template: ' + data.error, 'error');
                    }
                })
                .catch(error => {
                    showStatus('Error importing template: ' + error.message, 'error');
                });
            })
            .catch(error => {
                showStatus('Error reading template package: ' + error.message, 'error');
            });
        }

        // Removed IP field - auto-detection handled in backend

        function showStatus(message, type) {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
            
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 3000);
        }
    </script>
</body>
</html>